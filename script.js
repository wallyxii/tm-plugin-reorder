// ==UserScript==
// @name         TypingMind Plugin Reorder
// @namespace    https://github.com/your-username/typingmind-scripts
// @version      1.1
// @description  Allows drag-and-drop reordering of plugins on typingmind.com/#plugins. Includes a toggle button, hide option, and Shift+Alt+P shortcut.
// @author       Your Name (Generated by AI)
// @match        https://www.typingmind.com/*
// @grant        none
// ==/UserScript==

(function() {
    'use strict';

    // --- CONFIGURATION CONSTANTS ---
    const PLUGIN_PAGE_HASH = '#plugins'; // The hash for the plugins page
    const LS_ORDER_KEY = 'typingMindPluginOrder_v1'; // localStorage key for saving plugin order
    const LS_CONTROLS_HIDDEN_KEY = 'typingMindPluginControlsHidden_v1'; // localStorage key for control visibility

    // --- START OF CONFIGURABLE CSS SELECTORS ---
    // IMPORTANT: These selectors are CRITICAL for the script to work.
    // You may need to adjust them if TypingMind.com changes its HTML structure.
    // Use your browser's Developer Tools (Inspect Element) to find the correct selectors.

    // 1. PLUGIN_CONTAINER_SELECTOR:
    //    Selector for the HTML element that directly CONTAINS all the plugin cards you want to reorder.
    //    Example: If plugins are in <div class="plugin-grid">...</div>, use '.plugin-grid'.
    //    Based on common layouts and your images, this might be a <div> with Tailwind's `grid` class.
    const PLUGIN_CONTAINER_SELECTOR = 'main div[class*="grid"]'; // Highly speculative. Look for a 'grid' or 'flex' container holding plugin cards.
                                                                 // Could be more specific like 'div.grid.gap-4.grid-cols-...'

    // 2. PLUGIN_ITEM_SELECTOR:
    //    Selector for an INDIVIDUAL plugin card element, relative to the PLUGIN_CONTAINER_SELECTOR.
    //    Example: If each plugin is <div class="plugin-card">...</div>, use '.plugin-card'.
    //    Cards often have classes for background, border, padding, etc.
    const PLUGIN_ITEM_SELECTOR = 'div.border.rounded-lg'; // Speculative. Look for common card styling classes.
                                                          // e.g., 'div.bg-white.dark\\:bg-zinc-800.border'

    // 3. PLUGIN_NAME_SELECTOR:
    //    Selector for an element INSIDE each plugin card that contains the unique plugin NAME or TITLE.
    //    This text is used to identify plugins when saving their order.
    //    Example: If the name is in <h3 class="title">Plugin Name</h3>, use 'h3.title'.
    const PLUGIN_NAME_SELECTOR = 'h2, h3, .font-semibold, .text-lg'; // Try common heading/title classes.

    // 4. CONTROLS_INJECTION_POINT_SELECTOR:
    //    Selector for an HTML element where the "Reorder Plugins" and "Hide" buttons should be ADDED.
    //    This should be a stable element, like a toolbar or header area on the plugins page.
    //    Example: A div containing other action buttons like "Plugin Store".
    //    If the "Plugin Store" button has a unique ID or class, you could target its parent.
    const CONTROLS_INJECTION_POINT_SELECTOR = 'div.flex.items-center.justify-between'; // Speculative: A header div.
                                                                                      // This often contains page titles or action buttons.
    // --- END OF CONFIGURABLE CSS SELECTORS ---


    let isReorderModeActive = false;
    let draggedPlugin = null;
    let reorderButton = null;
    let hideControlsButton = null;
    let controlsContainerGlobal = null; // To keep track of the controls container

    /**
     * Injects CSS styles for the UI elements and drag-and-drop functionality.
     */
    function addStyles() {
        const css = `
            .tm-plugin-controls-container {
                display: flex;
                align-items: center;
                margin-left: 15px; /* Adjust as needed */
            }
            .tm-plugin-reorder-button, .tm-plugin-hide-controls-button {
                background-color: #4A5568; /* Tailwind gray-700 equivalent */
                color: white;
                padding: 8px 12px;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                margin-left: 8px;
                transition: background-color 0.2s ease-in-out;
                box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            }
            .tm-plugin-reorder-button:hover, .tm-plugin-hide-controls-button:hover {
                background-color: #2D3748; /* Tailwind gray-800 equivalent */
            }
            .tm-plugin-reorder-button.active {
                background-color: #38A169; /* Tailwind green-600 equivalent */
            }
            .tm-plugin-reorder-button.active:hover {
                background-color: #2F855A; /* Tailwind green-700 equivalent */
            }
            .tm-plugin-hide-controls-button {
                padding: 8px 10px;
                font-size: 14px; /* Ensure icon/text is clear */
                line-height: 1; /* For better icon alignment */
            }
            .plugin-draggable {
                cursor: grab !important;
                user-select: none; /* Prevent text selection during drag */
            }
            .plugin-draggable:active {
                cursor: grabbing !important;
            }
            .plugin-dragging {
                opacity: 0.6;
                border: 2px dashed #4A90E2; /* A distinct color for visibility */
                transform: scale(1.02); /* Slight lift effect */
            }
            .plugin-drag-over {
                /* Visual cue for where the item will be dropped */
                outline: 2px dashed #4A90E2;
                outline-offset: -2px;
                background-color: rgba(74, 144, 226, 0.1) !important; /* Light blueish tint */
            }
        `;
        const styleSheet = document.createElement("style");
        styleSheet.type = "text/css";
        styleSheet.innerText = css;
        document.head.appendChild(styleSheet);
    }

    /**
     * Gets a unique identifier for a plugin element.
     * @param {HTMLElement} pluginElement - The plugin DOM element.
     * @returns {string|null} The plugin's identifier (name/title) or null if not found.
     */
    function getPluginIdentifier(pluginElement) {
        if (!pluginElement) return null;
        const nameElement = pluginElement.querySelector(PLUGIN_NAME_SELECTOR);
        return nameElement ? nameElement.textContent.trim() : null;
    }

    /**
     * Saves the current order of plugins to localStorage.
     */
    function savePluginOrder() {
        const pluginContainer = document.querySelector(PLUGIN_CONTAINER_SELECTOR);
        if (!pluginContainer) return;

        const plugins = Array.from(pluginContainer.querySelectorAll(PLUGIN_ITEM_SELECTOR));
        const order = plugins.map(p => getPluginIdentifier(p)).filter(id => id !== null);
        localStorage.setItem(LS_ORDER_KEY, JSON.stringify(order));
        console.log('TypingMind Plugin Reorder: Order saved.', order);
    }

    /**
     * Loads the saved plugin order from localStorage and applies it to the page.
     */
    function loadAndApplyPluginOrder() {
        const pluginContainer = document.querySelector(PLUGIN_CONTAINER_SELECTOR);
        if (!pluginContainer) {
            console.warn('TypingMind Plugin Reorder: Plugin container not found for applying order.');
            return;
        }

        const savedOrderJSON = localStorage.getItem(LS_ORDER_KEY);
        if (!savedOrderJSON) {
            console.log('TypingMind Plugin Reorder: No saved order found.');
            return;
        }

        const savedOrder = JSON.parse(savedOrderJSON);
        if (!Array.isArray(savedOrder) || savedOrder.length === 0) return;

        const currentPlugins = Array.from(pluginContainer.querySelectorAll(PLUGIN_ITEM_SELECTOR));
        const pluginMap = new Map();
        currentPlugins.forEach(p => {
            const id = getPluginIdentifier(p);
            if (id) pluginMap.set(id, p);
        });

        // Re-append plugins in the saved order
        let reordered = false;
        savedOrder.forEach(id => {
            const pluginElement = pluginMap.get(id);
            if (pluginElement) {
                pluginContainer.appendChild(pluginElement);
                reordered = true;
            }
        });
        if(reordered) console.log('TypingMind Plugin Reorder: Plugin order applied.');
    }

    /**
     * Handles the drag start event.
     * @param {DragEvent} e - The drag event.
     */
    function handleDragStart(e) {
        if (!e.target.matches(PLUGIN_ITEM_SELECTOR)) return;
        draggedPlugin = e.target;
        e.dataTransfer.effectAllowed = 'move';
        // Optionally set data, though not strictly needed for DOM reordering within the same page
        // e.dataTransfer.setData('text/plain', getPluginIdentifier(draggedPlugin));
        setTimeout(() => { // Timeout to allow browser to render drag image before applying class
            if (draggedPlugin) draggedPlugin.classList.add('plugin-dragging');
        }, 0);
    }

    /**
     * Handles the drag over event for reordering.
     * @param {DragEvent} e - The drag event.
     */
    function handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';

        const targetItem = e.target.closest(PLUGIN_ITEM_SELECTOR);
        if (!targetItem || targetItem === draggedPlugin || !draggedPlugin || targetItem.parentElement !== draggedPlugin.parentElement) {
            // If not over a valid different item in the same container, clear previous highlights and exit
            document.querySelectorAll('.plugin-drag-over').forEach(el => el.classList.remove('plugin-drag-over'));
            return;
        }
        
        // Clear previous highlights before applying to new target
        document.querySelectorAll('.plugin-drag-over').forEach(el => el.classList.remove('plugin-drag-over'));
        targetItem.classList.add('plugin-drag-over');

        const container = targetItem.parentElement;
        const targetRect = targetItem.getBoundingClientRect();
        const draggedRect = draggedPlugin.getBoundingClientRect(); // Get current position of dragged item

        // Determine if dragging before or after the target based on mouse Y position relative to target's midpoint
        const isAfter = e.clientY > targetRect.top + targetRect.height / 2;

        if (isAfter) {
            // Insert draggedPlugin after targetItem
            // Check if draggedPlugin is not already after targetItem to prevent flickering
            if (targetItem.nextSibling !== draggedPlugin) {
                 container.insertBefore(draggedPlugin, targetItem.nextSibling);
            }
        } else {
            // Insert draggedPlugin before targetItem
            // Check if draggedPlugin is not already before targetItem
            if (targetItem.previousSibling !== draggedPlugin && targetItem !== draggedPlugin.nextSibling) {
                 container.insertBefore(draggedPlugin, targetItem);
            }
        }
    }


    /**
     * Handles the drop event.
     * @param {DragEvent} e - The drag event.
     */
    function handleDrop(e) {
        e.preventDefault();
        document.querySelectorAll('.plugin-drag-over').forEach(el => el.classList.remove('plugin-drag-over'));
        if (draggedPlugin) {
            draggedPlugin.classList.remove('plugin-dragging');
        }
        // The reordering is now done live in handleDragOver.
        // Final save of the order.
        savePluginOrder();
        draggedPlugin = null;
    }

    /**
     * Handles the drag end event.
     * @param {DragEvent} e - The drag event.
     */
    function handleDragEnd(e) {
        if (draggedPlugin) {
            draggedPlugin.classList.remove('plugin-dragging');
        }
        document.querySelectorAll('.plugin-drag-over').forEach(el => el.classList.remove('plugin-drag-over'));
        draggedPlugin = null;
        // Order is saved on drop. Could also save here as a final fallback if needed.
    }

    /**
     * Toggles the plugin reordering mode.
     */
    function toggleReorderMode() {
        isReorderModeActive = !isReorderModeActive;
        const pluginContainer = document.querySelector(PLUGIN_CONTAINER_SELECTOR);

        if (!pluginContainer) {
            console.warn('TypingMind Plugin Reorder: Plugin container not found for toggling mode.');
            isReorderModeActive = false; // Reset if container not found
        }

        if (reorderButton) {
            reorderButton.textContent = isReorderModeActive ? 'Save & Exit Reorder' : 'Reorder Plugins';
            reorderButton.classList.toggle('active', isReorderModeActive);
        }

        const plugins = pluginContainer ? Array.from(pluginContainer.querySelectorAll(PLUGIN_ITEM_SELECTOR)) : [];

        if (isReorderModeActive) {
            plugins.forEach(plugin => {
                plugin.setAttribute('draggable', 'true');
                plugin.classList.add('plugin-draggable');
                plugin.addEventListener('dragstart', handleDragStart);
                plugin.addEventListener('dragover', handleDragOver);
                plugin.addEventListener('drop', handleDrop);
                plugin.addEventListener('dragend', handleDragEnd);
            });
            console.log('TypingMind Plugin Reorder: Reorder mode ON.');
        } else {
            plugins.forEach(plugin => {
                plugin.removeAttribute('draggable');
                plugin.classList.remove('plugin-draggable');
                plugin.removeEventListener('dragstart', handleDragStart);
                plugin.removeEventListener('dragover', handleDragOver);
                plugin.removeEventListener('drop', handleDrop);
                plugin.removeEventListener('dragend', handleDragEnd);
            });
            savePluginOrder(); // Save order when exiting reorder mode
            console.log('TypingMind Plugin Reorder: Reorder mode OFF.');
        }
    }

    /**
     * Creates and adds the control buttons (Reorder, Hide) to the page.
     * @returns {boolean} True if controls were added, false otherwise.
     */
    function createAndAddControls() {
        if (document.querySelector('.tm-plugin-controls-container')) {
            return true; // Controls already exist
        }

        const injectionPoint = document.querySelector(CONTROLS_INJECTION_POINT_SELECTOR);
        if (!injectionPoint) {
            console.warn('TypingMind Plugin Reorder: Controls injection point not found. Cannot add buttons. Check CONTROLS_INJECTION_POINT_SELECTOR.');
            return false;
        }

        controlsContainerGlobal = document.createElement('div');
        controlsContainerGlobal.className = 'tm-plugin-controls-container';

        reorderButton = document.createElement('button');
        reorderButton.textContent = 'Reorder Plugins';
        reorderButton.className = 'tm-plugin-reorder-button';
        reorderButton.title = 'Toggle plugin reorder mode (Shift+Alt+P)';
        reorderButton.onclick = toggleReorderMode;
        controlsContainerGlobal.appendChild(reorderButton);

        hideControlsButton = document.createElement('button');
        hideControlsButton.innerHTML = '&#x1F5D9;&#xFE0F;'; // Wastebasket emoji (U+1F5D9, U+FE0F for emoji style)
        hideControlsButton.title = 'Hide reorder controls (Show again with Shift+Alt+P)';
        hideControlsButton.className = 'tm-plugin-hide-controls-button';
        hideControlsButton.onclick = () => {
            if (controlsContainerGlobal) controlsContainerGlobal.remove();
            localStorage.setItem(LS_CONTROLS_HIDDEN_KEY, 'true');
            if (isReorderModeActive) toggleReorderMode(); // Exit reorder mode if active
            console.log('TypingMind Plugin Reorder: Controls hidden.');
        };
        controlsContainerGlobal.appendChild(hideControlsButton);

        // Append to the injection point. You might want to use .prepend() depending on desired location.
        injectionPoint.appendChild(controlsContainerGlobal);
        console.log('TypingMind Plugin Reorder: Controls added to page.');
        return true;
    }

    /**
     * Shows the controls if they are hidden.
     */
    function showControls() {
        if (!document.querySelector('.tm-plugin-controls-container')) {
            if (createAndAddControls()) {
                localStorage.setItem(LS_CONTROLS_HIDDEN_KEY, 'false');
                console.log('TypingMind Plugin Reorder: Controls shown via shortcut.');
            }
        }
    }

    /**
     * Handles the keyboard shortcut (Shift + Alt + P).
     * @param {KeyboardEvent} e - The keyboard event.
     */
    function handleShortcut(e) {
        if (e.shiftKey && e.altKey && (e.key === 'P' || e.key === 'p')) {
            // Check if focus is on an input field, if so, don't trigger
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable)) {
                return;
            }
            
            e.preventDefault();
            console.log('TypingMind Plugin Reorder: Shortcut Shift+Alt+P pressed.');

            if (window.location.hash !== PLUGIN_PAGE_HASH) return; // Only on plugins page

            const controlsAreEffectivelyHidden = localStorage.getItem(LS_CONTROLS_HIDDEN_KEY) === 'true' || !document.querySelector('.tm-plugin-controls-container');

            if (controlsAreEffectivelyHidden) {
                showControls();
            } else {
                toggleReorderMode();
            }
        }
    }

    /**
     * Initializes the script. Checks if on the correct page, adds styles,
     * loads saved order, adds controls, and sets up event listeners.
     */
    function init() {
        // Ensure we are on the plugin page
        if (window.location.hash !== PLUGIN_PAGE_HASH) {
            // console.log('TypingMind Plugin Reorder: Not on plugin page, script inactive.');
            // Clean up if navigating away from plugin page
            if (controlsContainerGlobal) {
                controlsContainerGlobal.remove();
                controlsContainerGlobal = null;
                reorderButton = null;
                hideControlsButton = null;
            }
            document.removeEventListener('keydown', handleShortcut); // Remove listener if not on page
            return;
        }
        console.log('TypingMind Plugin Reorder: Initializing on plugin page.');

        addStyles();

        // Wait for plugin container to ensure elements are loaded, especially for Single Page Applications
        let attempts = 0;
        const maxAttempts = 30; // Increased attempts for slower loading pages
        const intervalId = setInterval(() => {
            const pluginContainer = document.querySelector(PLUGIN_CONTAINER_SELECTOR);
            const injectionPoint = document.querySelector(CONTROLS_INJECTION_POINT_SELECTOR);

            if (pluginContainer && injectionPoint) {
                clearInterval(intervalId);
                console.log('TypingMind Plugin Reorder: Plugin container and injection point found.');
                
                loadAndApplyPluginOrder(); // Apply saved order first

                const controlsHidden = localStorage.getItem(LS_CONTROLS_HIDDEN_KEY) === 'true';
                if (!controlsHidden) {
                    if (!createAndAddControls()) {
                        console.error("TypingMind Plugin Reorder: Failed to create and add controls even after finding injection point. Check selectors.");
                    }
                } else {
                    console.log('TypingMind Plugin Reorder: Controls are set to hidden by user preference.');
                }
                // Add shortcut listener only once after successful init on the page
                document.removeEventListener('keydown', handleShortcut); // Remove previous if any
                document.addEventListener('keydown', handleShortcut);

            } else {
                attempts++;
                if (attempts > maxAttempts) {
                    clearInterval(intervalId);
                    console.warn(`TypingMind Plugin Reorder: Could not find critical elements after ${maxAttempts} attempts.
                    - Plugin Container (${PLUGIN_CONTAINER_SELECTOR}): ${pluginContainer ? 'Found' : 'NOT FOUND'}
                    - Injection Point (${CONTROLS_INJECTION_POINT_SELECTOR}): ${injectionPoint ? 'Found' : 'NOT FOUND'}
                    Script may not function correctly. Please verify CSS selectors in the script.`);
                }
            }
        }, 500); // Check every 500ms
    }

    /**
     * Re-initialize when the page hash changes (for SPA navigation).
     */
    function onHashChange() {
        // A small delay to allow the new page content to potentially render
        setTimeout(init, 100);
    }

    // Initial load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
    // Listen for hash changes to re-initialize if navigating within the SPA
    window.addEventListener('hashchange', onHashChange);

})();
